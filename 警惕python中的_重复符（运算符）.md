# 警惕python中的*重复符（运算符）

在python中有个特殊的符号“*”，可以用做数值运算的乘法算子，也是用作对象的重复算子，但在作为重复算子使用时一定要注意  

注意的是：*重复出来的各对象具有同一个id，也就是指向在内存中同一块地址，在对各个对象进行操作是一定要注意。

举例来说：

    
    
    >>> alist = [range(3)]*4
    >>> alist
    [[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]

上面初始化一个二层列表用来模拟矩阵，该矩阵式4X3的，为描述方便，这里记矩阵为A。

现在我想给A11赋值为1，用下面的代码：

    
    
    alist[0][0]=1

那我们想要的结果应该是：

    
    
    [[1, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]

可是很不幸，我们得到的是：

    
    
    [[1, 1, 2], [1, 1, 2], [1, 1, 2], [1, 1, 2]]

这是怎么回事呢，为什么给A21赋值，其他的Ai1为什么都跟着变了呢？

  

原因是这样的：

文章开始的时候我们已经说过了，***重复出来的各对象具有同一个id，也就是指向在内存中同一块地址，在对各个对象进行操作是一定要注意**。

我们再初始化的时候用了重复算子"*"，这个操作符在对对象进行重复操作时，会将重复的所有对象都指向同一块内存地址，所有当你改变其中的一个值时，

其他的值自然也会更新，用python的话进行解释就是下面的命令及输出：

    
    
    >>> id(alist[0])
    18858192
    >>> id(alist[1])
    18858192
    >>> id(alist[2])
    18858192
    >>> id(alist[3])
    18858192
    >>>

看到了吧，id都是一样滴，也就是说这4个list是同一个“list”。

既然这样那我们想要模拟一个矩阵怎么办呢，除了有专门的numpy包之外，你当然可以给上层list逐个的append新的list，例如：

    
    
    >>> blist=[]
    >>> for i in range(4):
        blist.append([j for j in range(3)])
    >>> blist
    [[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]

这样，我们再试试上面的赋值操作：

    
    
    >>> blist[0][0]=1
    >>> blist
    [[1, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
    >>>

  

